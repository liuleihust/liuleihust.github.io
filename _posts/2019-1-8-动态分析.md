# 动态分析

```c++
/*********************************************************************
系统初始化过程中/
/*初始化同步变量，内存系统和线程 */
void
srv_general_init(void)
/*==================*/
{
	sync_check_init();
	/* Reset the system variables in the recovery module. */
	recv_sys_var_init();
	os_thread_init();
	trx_pool_init();
	que_init();
	row_mysql_init();
}
```

`trx_pool_init` 在服务启动过程中进行 初始化:

```c++
/** Use explicit mutexes for the trx_t pool and its manager. */
typedef Pool<trx_t, TrxFactory, TrxPoolLock> trx_pool_t;  // 定义了一个 trx_pool_t 
typedef PoolManager<trx_pool_t, TrxPoolManagerLock > trx_pools_t; //定义了一个缓冲池管理

/** The trx_t pool manager */
static trx_pools_t* trx_pools;

/** Size of on trx_t pool in bytes. */
static const ulint MAX_TRX_BLOCK_SIZE = 1024 * 1024 * 4;

/** Create the trx_t pool */
void
trx_pool_init()
{
    // 创建 一些缓冲池 交给 trx_pools
	trx_pools = UT_NEW_NOKEY(trx_pools_t(MAX_TRX_BLOCK_SIZE));

	ut_a(trx_pools != 0); // 如果 trx_pools ==0  则中止运行
}
```

`trx_pools`  时 一个 `trx_pools_t` 的指针，`UT_NEW_NOKEY`分配内存空间并返回内存指针。`trx_pools_t(MAX_TRX_BLOCK_SIZE)`生成4M的空间。

**trx_pools_t**定义：

```c++
template <typename Pool, typename LockStrategy>  //需要提供 池中 对象，锁的策略
struct PoolManager {

	typedef Pool PoolType;
	typedef typename PoolType::value_type value_type;

	PoolManager(size_t size)
		:
		m_size(size)
	{
		create();
	}

	~PoolManager()
	{
		destroy();

		ut_a(m_pools.empty());
	}

	/** Get an element from one of the pools.
	@return instance or NULL if pool is empty. */
	value_type* get()      //通过 get 函数 从池中拿一个对象。
	{
		size_t		index = 0;     
		size_t		delay = 1;
		value_type*	ptr = NULL;   //创建一个  value_type 的指针

		do {
			m_lock_strategy.enter();  //  锁定

			ut_ad(!m_pools.empty());  //如果 为空则 声明， 仅对 deBug 状态下有用

			size_t	n_pools = m_pools.size(); //缓冲池的数目

			PoolType*	pool = m_pools[index % n_pools];  //得到一个缓冲池

			m_lock_strategy.exit();  //解开锁

			ptr = pool->get();   //返回指针 

			if (ptr == 0 && (index / n_pools) > 2) {

				if (!add_pool(n_pools)) {  //如果 添加 失败  

					ib::error() << "Failed to allocate"
						" memory for a pool of size "
						<< m_size << " bytes. Will"
						" wait for " << delay
						<< " seconds for a thread to"
						" free a resource";

					/* There is nothing much we can do
					except crash and burn, however lets
					be a little optimistic and wait for
					a resource to be freed. */
					os_thread_sleep(delay * 1000000);    //让线程睡一会 等待 资源释放 

					if (delay < 32) {
						delay <<= 1;
					}

				} else {
					delay = 1;
				}
			}

			++index;

		} while (ptr == NULL);

		return(ptr);
	}

	static void mem_free(value_type* ptr)
	{
		PoolType::mem_free(ptr);
	}

private:
	/** Add a new pool
	@param n_pools Number of pools that existed when the add pool was
			called.
	@return true on success */
	bool add_pool(size_t n_pools)
	{
		bool	added = false;

		m_lock_strategy.enter();

		if (n_pools < m_pools.size()) {
			/* Some other thread already added a pool. */
			added = true;
		} else {
			PoolType*	pool;

			ut_ad(n_pools == m_pools.size());

			pool = UT_NEW_NOKEY(PoolType(m_size));

			if (pool != NULL) {

				ut_ad(n_pools <= m_pools.size());

				m_pools.push_back(pool);

				ib::info() << "Number of pools: "
					<< m_pools.size();

				added = true;
			}
		}

		ut_ad(n_pools < m_pools.size() || !added);

		m_lock_strategy.exit();

		return(added);
	}

	/** Create the pool manager. */
	void create()
	{
		ut_a(m_size > sizeof(value_type));
		m_lock_strategy.create();

		add_pool(0);
	}

	/** Release the resources. */
	void destroy()
	{
		typename Pools::iterator it;
		typename Pools::iterator end = m_pools.end();

		for (it = m_pools.begin(); it != end; ++it) {
			PoolType*	pool = *it;

			UT_DELETE(pool);
		}

		m_pools.clear();

		m_lock_strategy.destroy();
	}
private:
	// Disable copying
	PoolManager(const PoolManager&);
	PoolManager& operator=(const PoolManager&);

	typedef std::vector<PoolType*, ut_allocator<PoolType*> >	Pools;

	/** Size of each block */
	size_t		m_size;

	/** Pools managed this manager */
	Pools		m_pools;

	/** Lock strategy to use */
	LockStrategy		m_lock_strategy;
};

```

`trx_pool_mange ` 主要进行 `trx_t` 对象的分配，当缓冲池 不够的情况下可以添加一些pool。当内存不足时，会等待一会 ，等待 其他线程释放 资源。

`trx_pool_t` 是一个Pool模板类实例，Pool模板类定义如下：   

`typedef Pool<trx_t, TrxFactory, TrxPoolLock> trx_pool_t;`

```c++
template <typename Type, typename Factory, typename LockStrategy>
struct Pool {

	typedef Type value_type;

	// FIXME: Add an assertion to check alignment and offset is
	// as we expect it. Also, sizeof(void*) can be 8, can we impove on this.
	struct Element {  // 缓冲池中的对象 ，包含一个缓冲池指针和 一个事务对象。
		Pool*		m_pool;
		value_type	m_type;
	};

	/** Constructor
	@param size size of the memory block */
	Pool(size_t size)
		:
		m_end(),
		m_start(),
		m_size(size),
		m_last()
	{
		ut_a(size >= sizeof(Element));

		m_lock_strategy.create();

		ut_a(m_start == 0);

		m_start = reinterpret_cast<Element*>(ut_zalloc_nokey(m_size));  //reinterpret_cast 强制类型转换符,它让程序员能够将一种对象类型转换为另一种，不管它们是否相关。主要用于不同指针的转换。改变了编译器对于源对象的类型解释。

		m_last = m_start;

		m_end = &m_start[m_size / sizeof(*m_start)];

		/* 只初始化一个小子集， */

		init(ut_min(size_t(16), size_t(m_end - m_start)));  //最多初始化 16个 trx 对象

		ut_ad(m_pqueue.size() <= size_t(m_last - m_start));
	}

	/** Destructor */
	~Pool()
	{
		m_lock_strategy.destroy();

		for (Element* elem = m_start; elem != m_last; ++elem) {

			ut_ad(elem->m_pool == this);
			Factory::destroy(&elem->m_type);
		}

		ut_free(m_start);
		m_end = m_last = m_start = 0;
		m_size = 0;
	}

	/** Get an object from the pool.
	@retrun a free instance or NULL if exhausted. */
	Type*	get()
	{
		Element*	elem;

		m_lock_strategy.enter();

		if (!m_pqueue.empty()) {

			elem = m_pqueue.top();
			m_pqueue.pop();

		} else if (m_last < m_end) {

			/* Initialise the remaining elements. */
			init(m_end - m_last);

			ut_ad(!m_pqueue.empty());

			elem = m_pqueue.top();
			m_pqueue.pop();
		} else {
			elem = NULL;
		}

		m_lock_strategy.exit();

		return(elem != NULL ? &elem->m_type : 0);
	}

	/** Add the object to the pool.
	@param ptr object to free */
	static void mem_free(value_type* ptr)
	{
		Element*	elem;
		byte*		p = reinterpret_cast<byte*>(ptr + 1);

		elem = reinterpret_cast<Element*>(p - sizeof(*elem));

		elem->m_pool->put(elem);
	}

protected:
	// Disable copying
	Pool(const Pool&);
	Pool& operator=(const Pool&);

private:

	/* We only need to compare on pointer address. */
	typedef std::priority_queue<
		Element*,
		std::vector<Element*, ut_allocator<Element*> >,
		std::greater<Element*> >	pqueue_t;

	/** Release the object to the free pool
	@param elem element to free */
	void put(Element* elem)
	{
		m_lock_strategy.enter();

		ut_ad(elem >= m_start && elem < m_last);

		ut_ad(Factory::debug(&elem->m_type));

		m_pqueue.push(elem);

		m_lock_strategy.exit();
	}

	/**初始化元素.
	@param n_elems Number of elements to initialise */
	void init(size_t n_elems)
	{
		ut_ad(size_t(m_end - m_last) >= n_elems);

		for (size_t i = 0; i < n_elems; ++i, ++m_last) {

			m_last->m_pool = this;   // pool 指针 指向这个 pool 
			Factory::init(&m_last->m_type);
			m_pqueue.push(m_last);  //加入指针队列
		}

		ut_ad(m_last <= m_end);
	}

private:
	/** 指向最后一个元素 */
	Element*		m_end;

	/** Pointer to the first element */
	Element*		m_start;

	/** Size of the block in bytes */
	size_t			m_size;

	/** 使用空间的上限 */
	Element*		m_last;

	/** Priority queue ordered on the pointer addresse. */
	pqueue_t		m_pqueue;

	/** Lock strategy to use */
	LockStrategy		m_lock_strategy;
};

```



**TrxFactory**是一个类，定义如下：  TrxFactory的功能是回收和创建`trx_t`对象。 

```C++
struct TrxFactory {

	/** Initializes a transaction object. It must be explicitly started
	with trx_start_if_not_started() before using it. The default isolation
	level is TRX_ISO_REPEATABLE_READ.
	@param trx Transaction instance to initialise */
	static void init(trx_t* trx)
	{
		/* trx 对象空间已经分配。 */
		new(&trx->mod_tables) trx_mod_tables_t(); //trx_mod_tables_t 存放了 这个事务 修改的表对象的指针

		new(&trx->lock.rec_pool) lock_pool_t(); //Pre-allocated record locks

		new(&trx->lock.table_pool) lock_pool_t(); //Pre-allocated table locks

		new(&trx->lock.table_locks) lock_pool_t(); //All table locks requested by this
					transaction, including AUTOINC locks

		new(&trx->hit_list) hit_list_t();/  /List of transactions to kill,
					when a high priority transaction
					is blocked on a lock wait. 

		trx_init(trx); // 事务的初始化 包括 id,no,isolation_level,table_id

		trx->state = TRX_STATE_NOT_STARTED; // 设置事务状态

		trx->dict_operation_lock_mode = 0; //对数据字典的锁类型

		trx->xid = UT_NEW_NOKEY(xid_t());

		trx->detailed_error = reinterpret_cast<char*>(
			ut_zalloc_nokey(MAX_DETAILED_ERROR_LEN));

		trx->lock.lock_heap = mem_heap_create_typed(
			1024, MEM_HEAP_FOR_LOCK_HEAP);

		lock_trx_lock_list_init(&trx->lock.trx_locks);

		UT_LIST_INIT(
			trx->trx_savepoints,
			&trx_named_savept_t::trx_savepoints);

		mutex_create(LATCH_ID_TRX, &trx->mutex);
		mutex_create(LATCH_ID_TRX_UNDO, &trx->undo_mutex);

		lock_trx_alloc_locks(trx);
	}

	/** Release resources held by the transaction object.
	@param trx the transaction for which to release resources */
	static void destroy(trx_t* trx)
	{
		ut_a(trx->magic_n == TRX_MAGIC_N);
		ut_ad(!trx->in_rw_trx_list);
		ut_ad(!trx->in_mysql_trx_list);

		ut_a(trx->lock.wait_lock == NULL);
		ut_a(trx->lock.wait_thr == NULL);

		ut_a(!trx->has_search_latch);

		ut_a(trx->dict_operation_lock_mode == 0);

		if (trx->lock.lock_heap != NULL) {
			mem_heap_free(trx->lock.lock_heap);
			trx->lock.lock_heap = NULL;
		}

		ut_a(UT_LIST_GET_LEN(trx->lock.trx_locks) == 0);

		UT_DELETE(trx->xid);
		ut_free(trx->detailed_error);

		mutex_free(&trx->mutex);
		mutex_free(&trx->undo_mutex);

		trx->mod_tables.~trx_mod_tables_t();

		ut_ad(trx->read_view == NULL);

		if (!trx->lock.rec_pool.empty()) {

			/* See lock_trx_alloc_locks() why we only free
			the first element. */

			ut_free(trx->lock.rec_pool[0]);
		}

		if (!trx->lock.table_pool.empty()) {

			/* See lock_trx_alloc_locks() why we only free
			the first element. */

			ut_free(trx->lock.table_pool[0]);
		}

		trx->lock.rec_pool.~lock_pool_t();

		trx->lock.table_pool.~lock_pool_t();

		trx->lock.table_locks.~lock_pool_t();

		trx->hit_list.~hit_list_t();
	}

	/** Enforce any invariants here, this is called before the transaction
	is added to the pool.
	@return true if all OK */
	static bool debug(const trx_t* trx)
	{
		ut_a(trx->error_state == DB_SUCCESS);

		ut_a(trx->magic_n == TRX_MAGIC_N);

		ut_ad(!trx->read_only);

		ut_ad(trx->state == TRX_STATE_NOT_STARTED
		      || trx->state == TRX_STATE_FORCED_ROLLBACK);

		ut_ad(trx->dict_operation == TRX_DICT_OP_NONE);

		ut_ad(trx->mysql_thd == 0);

		ut_ad(!trx->in_rw_trx_list);
		ut_ad(!trx->in_mysql_trx_list);

		ut_a(trx->lock.wait_thr == NULL);
		ut_a(trx->lock.wait_lock == NULL);

		ut_a(!trx->has_search_latch);

		ut_a(trx->dict_operation_lock_mode == 0);

		ut_a(UT_LIST_GET_LEN(trx->lock.trx_locks) == 0);

		ut_ad(trx->autoinc_locks == NULL);

		ut_ad(trx->lock.table_locks.empty());

		ut_ad(!trx->abort);

		ut_ad(trx->hit_list.empty());

		ut_ad(trx->killed_by == 0);

		return(true);
	}
};

```



总结：`trx_t pool manager` 管理这 `trx_pool`。用来生成与删除`trx_pool`。`trx_pool`调用**TrxFactory**初始化事务缓冲池，能够从字节的缓冲池中分配初始化的trx对象。 该操作一次连接做一次。



事务提交 函数

```
innobase_commit(handlerton*	hton,THD*  thd,bool commit_trx) // commit_trx = true 时 提交
-- innobase_commit_low(trx_t*	trx)  //handle 层调用 commit 函数
----- trx_commit(trx_t*	trx)  //  trx0trx.cc  文件中 Does the transaction commit for MySQL.
-- trx_deregister_from_2pc(trx);  // 标记这个事务已经被撤销
-- innobase_srv_conc_force_exit_innodb(trx); // 强制一个线程离开InnoDB


```

选择数据库 test001

```
use test001;


dict_stats_fetch_from_ps(dict_table_t*	table) // 从存储中读取表的统计信息
-- trx_t* trx_allocate_for_background(void) //  通过主线程为后台操作创建事务对象 trx0trx.cc
----- trx_t* trx_create_low()  // 从 trx_pools 中返回一个事务 实例。
-- 如果是只读事务则 trx_start_internal_read_only(trx); == trx_start_internal_read_only_low（trx)
-----trx_start_low(trx, false);
-- 否则 trx_start_internal(trx);==trx_start_internal_low((t))
---- trx_start_low(trx, true);
-- trx_commit_for_mysql(trx); // 提交事务
-----
-- trx_free_for_background(trx); // 释放被Master thread 拥有的事务
handler::ha_open(TABLE *table_arg, const char *name, int mode,
                   int test_if_locked) //  Open database-handler. 
-- int ha_innobase::open() //Creates and opens a handle to a table which already exists in an InnoDB database. 
----ha_innobase::info () //  返回表信息给mysql 解释权
-------ha_innobase::update_thd(） //更新一个用户线程，如果需要 分配一个事务
----------check_trx_exists（thd） //检查该线程是否拥有 事务 ，如果没有则分配一个
------------- trx = innobase_trx_allocate(thd); // 为DML的MySQL处理程序对象分配一个InnoDB事务。
------------------trx_allocate_for_mysql(void) //Creates a transaction object for MySQL.
-----------------------trx_allocate_for_background(void) //通过主线程创造事务对象
---------------------------trx_t* trx_create_low()  // 从 trx_pools 中返回一个事务 实例。
```

trx_create_low 函数

```c++
static
trx_t*
trx_create_low()
{
	trx_t*	trx = trx_pools->get();  //从 事务池管理中获取一个事务实例

	assert_trx_is_free(trx);  //检查事务是否空闲，以便可以重新初始化它。 

	mem_heap_t*	heap;   //生成一个内存堆 
	ib_alloc_t*	alloc;  // 分配内存

	/* We just got trx from pool, it should be non locking */
	ut_ad(trx->will_lock == 0);  

	trx->api_trx = false;   // 事务是否通过InnoDB API开启

	trx->api_auto_commit = false;  //事务是否自动提交 

	trx->read_write = true;  //一个读写事务

	/* Background trx should not be forced to rollback,
	we will unset the flag for user trx. */
	trx->in_innodb |= TRX_FORCE_ROLLBACK_DISABLE;

	/* Trx state can be TRX_STATE_FORCED_ROLLBACK if
	the trx was forced to rollback before it's reused.*/
	trx->state = TRX_STATE_NOT_STARTED;  

	heap = mem_heap_create(sizeof(ib_vector_t) + sizeof(void*) * 8);

	alloc = ib_heap_allocator_create(heap);   //创造内存空间

	/* Remember to free the vector explicitly in trx_free(). */
	trx->autoinc_locks = ib_vector_create(alloc, sizeof(void**), 4);   //该事物拥有的自增锁

	/* Should have been either just initialized or .clear()ed by
	trx_free(). */
	ut_a(trx->mod_tables.size() == 0);

	return(trx);
}

```

## Select 语句的执行

```C++
mysql> select * from test;  //
默认隔离级别：RR；
autocommit=true，也就是说每一个sql语句都会被当作一个事务来对待；

row_search_mvcc(buf, mode, m_prebuilt, match_mode, 0);
-- trx_start_if_not_started(trx, false); ==trx_start_if_not_started_low((t), rw) //如果没有开启事务则开启事务
----- 
```

innobase_commit 函数

```c++
static
int
innobase_commit(
/*============*/
	handlerton*	hton,		/*!< in: InnoDB 操作者 */
	THD*		thd,		//事务应该提交给的用户的MySQL线程句柄
	bool		commit_trx)	/*!< in: true - commit transaction
					false - the current SQL statement
					ended */
{
	DBUG_ENTER("innobase_commit");
	DBUG_ASSERT(hton == innodb_hton_ptr);
	DBUG_PRINT("trans", ("ending transaction"));

	trx_t*	trx = check_trx_exists(thd);  //检查该线程中是否存在事务，如果没有则创建一个事务，

	TrxInInnoDB	trx_in_innodb(trx); //Track if a transaction is executing inside InnoDB code. .

	if (trx_in_innodb.is_aborted()) {  // 如果该事物被标记为异步回滚

		innobase_rollback(hton, thd, commit_trx);  //回滚

		DBUG_RETURN(convert_error_code_to_mysql(
			DB_FORCED_ABORT, 0, thd));
	}

	ut_ad(trx->dict_operation_lock_mode == 0);
	ut_ad(trx->dict_operation == TRX_DICT_OP_NONE);

	/*事务仅在提交或回滚中注销。如果它被注销了，我们知道没有资源可以释放我们可以马上回来。就目前而言，我们是安全的尽管没有东西可以清理，但还是要进行清理。 */

	if (!trx_is_registered_for_2pc(trx) && trx_is_started(trx)) {  // 如果事务没有被注销而且事务的状态是活跃的就输出警告信息

		sql_print_error("Transaction not registered for MySQL 2PC,"
				" but transaction is active");
	}

	bool	read_only = trx->read_only || trx->id == 0;  // 判断是否为只读事务

	if (commit_trx
	    || (!thd_test_options(thd, OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))) {  //如果明确 commit 或者这是一个SQL 语句结束并且自动提交时打开的 则提交事务

		/* We were instructed to commit the whole transaction, or
		this is an SQL statement end and autocommit is on */

		/* We need current binlog position for mysqlbackup to work. */

		if (!read_only) {  // 这段代码时为了 并发提交的是写 binlog 
 
			while (innobase_commit_concurrency > 0) {   //innobase_commit_concurrency 默认是0

				mysql_mutex_lock(&commit_cond_m);

				++commit_threads;

				if (commit_threads
				    <= innobase_commit_concurrency) {

					mysql_mutex_unlock(&commit_cond_m);
					break;
				}

				--commit_threads;

				mysql_cond_wait(&commit_cond, &commit_cond_m);

				mysql_mutex_unlock(&commit_cond_m);
			}

			/* 下面的调用读取正在提交的事务的二进制日志位置。其他引擎的二进制日志记录与InnoDB无关，因为InnoDB要求提交InnoDB事务的顺序与提交InnoDB事务的顺序相同，这是由服务器保证的。如果没有启用二进制日志，或者事务没有写入二进制日志，则文件名将被写入成为空指针。 */
			ulonglong	pos;

			thd_binlog_pos(thd, &trx->mysql_log_file_name, &pos);

			trx->mysql_log_offset = static_cast<int64_t>(pos);

			/* Don't do write + flush right now. For group commit
			to work we want to do the flush later. */
			trx->flush_log_later = true;
		}

		innobase_commit_low(trx); //innobase 提交

		if (!read_only) {
			trx->flush_log_later = false;

			if (innobase_commit_concurrency > 0) {

				mysql_mutex_lock(&commit_cond_m);

				ut_ad(commit_threads > 0);
				--commit_threads;

				mysql_cond_signal(&commit_cond);

				mysql_mutex_unlock(&commit_cond_m);
			}
		}

		trx_deregister_from_2pc(trx);

		/* Now do a write + flush of logs. */
		if (!read_only) {
			trx_commit_complete_for_mysql(trx);  //应用了 group commit
		}

	} else {
		/* 仅仅标记SQL语句结束 */

		/* 如果获得表自增锁则释放*/

		if (!read_only) {
			lock_unlock_table_autoinc(trx);
		}

		/* 存储事务undo_no */

		trx_mark_sql_stat_end(trx);
	}

	/* Reset the number AUTO-INC rows required */
	trx->n_autoinc_rows = 0;

	/* This is a statement level variable. */
	trx->fts_next_doc_id = 0;

	innobase_srv_conc_force_exit_innodb(trx);

	DBUG_RETURN(0);
}
```





检查事务存在函数：

```c++
static inline
trx_t*
check_trx_exists(
/*=============*/
	THD*	thd)	/*!< in: user thread handle */
{
	trx_t*&	trx = thd_to_trx(thd); // 获得这个线程的事务，返回这个事务的指针

	ut_ad(EQ_CURRENT_THD(thd));

	if (trx == NULL) {  
		trx = innobase_trx_allocate(thd);  //如果这个事务 为空则，

		/* User trx can be forced to rollback,
		so we unset the disable flag. */
		ut_ad(trx->in_innodb & TRX_FORCE_ROLLBACK_DISABLE);
		trx->in_innodb &= TRX_FORCE_ROLLBACK_MASK;
	} else {
		ut_a(trx->magic_n == TRX_MAGIC_N);

		innobase_trx_init(thd, trx); //如果存在 在初始化 
	}

	return(trx);
}
```

事务分配函数：

```c++
trx_t*
innobase_trx_allocate(
/*==================*/
	THD*	thd)	/*!< in: user thread handle */
{
	trx_t*	trx;

	DBUG_ENTER("innobase_trx_allocate");
	DBUG_ASSERT(thd != NULL);
	DBUG_ASSERT(EQ_CURRENT_THD(thd));

	trx = trx_allocate_for_mysql();

	trx->mysql_thd = thd;

	innobase_trx_init(thd, trx);

	DBUG_RETURN(trx);
}
```

```
innobase_trx_allocate
--trx_allocate_for_mysql();
----trx_allocate_for_background()
--------trx_create_low()
```

事务提交

```c++
innobase_commit(handlerton*	hton,THD*  thd,bool commit_trx) // commit_trx = true 时 提交
--void innobase_commit_low(trx)
----trx_commit_for_mysql(trx）
--------trx_commit（trx) 
------------trx_commit_low()
---------------trx_commit_in_memory（） // mtr 的提交涉及到这个
```

如果事务未开启则开启

```c++
void
trx_start_if_not_started_low(
/*==========================*/
	trx_t*	trx,		/*!< in: transaction */
	bool	read_write)	/*!< in: true if read write transaction */
{
	switch (trx->state) {
	case TRX_STATE_NOT_STARTED:
	case TRX_STATE_FORCED_ROLLBACK:

		trx_start_low(trx, read_write);
		return;

	case TRX_STATE_ACTIVE:

		if (read_write && trx->id == 0 && !trx->read_only) {  // 如果事务状态为活跃，并且是个读写事务，并且 事务id 是0 ，并且该事务不是只读事务，则改变事务模式，分配事务id 
			trx_set_rw_mode(trx);
		}
		return;

	case TRX_STATE_PREPARED:
	case TRX_STATE_COMMITTED_IN_MEMORY:
		break;
	}

	ut_error;
}
```



事务开启

```C++
Starts a transaction. */
static
void
trx_start_low(
/*==========*/
	trx_t*	trx,		/*!< in: transaction */
	bool	read_write)	/*!< in: true if read-write transaction */
{
	ut_ad(!trx->in_rollback);
	ut_ad(!trx->is_recovered);
	ut_ad(trx->hit_list.empty());
	ut_ad(trx->start_line != 0);
	ut_ad(trx->start_file != 0);
	ut_ad(trx->roll_limit == 0);
	ut_ad(trx->error_state == DB_SUCCESS);
	ut_ad(trx->rsegs.m_redo.rseg == NULL);
	ut_ad(trx->rsegs.m_noredo.rseg == NULL);
	ut_ad(trx_state_eq(trx, TRX_STATE_NOT_STARTED));
	ut_ad(UT_LIST_GET_LEN(trx->lock.trx_locks) == 0);
	ut_ad(!(trx->in_innodb & TRX_FORCE_ROLLBACK));
	ut_ad(!(trx->in_innodb & TRX_FORCE_ROLLBACK_ASYNC));

	++trx->version; // 因为一个连接共用一个事务实例，每次开启事务后，更新事务版本号。

	/* Check whether it is an AUTOCOMMIT SELECT */
	trx->auto_commit = (trx->api_trx && trx->api_auto_commit)   //检查是否是自动提交事务，
			   || thd_trx_is_auto_commit(trx->mysql_thd);

	trx->read_only =  //检查是否是只读事务
		(trx->api_trx && !trx->read_write)
		|| (!trx->ddl && !trx->internal
		    && thd_trx_is_read_only(trx->mysql_thd))
		|| srv_read_only_mode;

	if (!trx->auto_commit) { // 如果不是自动提交事务 。可能获得锁+1 
		++trx->will_lock;
	} else if (trx->will_lock == 0) {  //如果是 自动提交事务，并且可能获得锁为0，则为只读事务 
		trx->read_only = true;
	}

#ifdef UNIV_DEBUG
	/* If the transaction is DD attachable trx, it should be AC-NL-RO-RC
	(AutoCommit-NonLocking-ReadOnly-ReadCommited) trx */
	if (trx->is_dd_trx) {
		ut_ad(trx->read_only && trx->auto_commit
		      && trx->isolation_level == TRX_ISO_READ_COMMITTED);
	}
#endif /* UNIV_DEBUG */

	/* The initial value for trx->no: TRX_ID_MAX is used in
	read_view_open_now: */

	trx->no = TRX_ID_MAX;  //trx->no  初始值 =  TRX_ID_MAX (此值为常量值)

	ut_a(ib_vector_is_empty(trx->autoinc_locks));
	ut_a(trx->lock.table_locks.empty());

	/* If this transaction came from trx_allocate_for_mysql(),
	trx->in_mysql_trx_list would hold. In that case, the trx->state
	change must be protected by the trx_sys->mutex, so that
	lock_print_info_all_transactions() will have a consistent view. */

	ut_ad(!trx->in_rw_trx_list); // 如果该事物来自trx_allocate_for_mysql()，

	/* We tend to over assert and that complicates the code somewhat.
	e.g., the transaction state can be set earlier but we are forced to
	set it under the protection of the trx_sys_t::mutex because some
	trx list assertions are triggered unnecessarily. */

	/* By default all transactions are in the read-only list unless they
	are non-locking auto-commit read only transactions or background
	(internal) transactions. Note: Transactions marked explicitly as
	read only can write to temporary tables, we put those on the RO
	list too. */

	if (!trx->read_only
	    && (trx->mysql_thd == 0 || read_write || trx->ddl)) { //如果是 读写事务

		trx->rsegs.m_redo.rseg = trx_assign_rseg_low(  //分配回滚段
			srv_rollback_segments,
			srv_undo_tablespaces,
			TRX_RSEG_TYPE_REDO);

		/* Temporary rseg is assigned only if the transaction
		updates a temporary table */

		trx_sys_mutex_enter();

		trx->id = trx_sys_get_new_trx_id（）；  // 获得 新的 id 

		trx_sys->rw_trx_ids.push_back(trx->id);  // 加入 rw_trx_ids

		trx_sys_rw_trx_add(trx);   // 加入 RW transaction set 

		ut_ad(trx->rsegs.m_redo.rseg != 0
		      || srv_read_only_mode
		      || srv_force_recovery >= SRV_FORCE_NO_TRX_UNDO);

		UT_LIST_ADD_FIRST(trx_sys->rw_trx_list, trx);

		ut_d(trx->in_rw_trx_list = true);
#ifdef UNIV_DEBUG
		if (trx->id > trx_sys->rw_max_trx_id) {  //更新读写 事务的最大ID 
			trx_sys->rw_max_trx_id = trx->id;
		}
#endif /* UNIV_DEBUG */

		trx->state = TRX_STATE_ACTIVE;  //设置事务状态为 TRX_STATE_ACTIVE

		ut_ad(trx_sys_validate_trx_list());

		trx_sys_mutex_exit();

	} else {
		trx->id = 0;   //如果为 只读事务 则设定 id = 0 

		if (!trx_is_autocommit_non_locking(trx)) {  // 如果不是非锁定自动提交的选择事务

			/* If this is a read-only transaction that is writing
			to a temporary table then it needs a transaction id
			to write to the temporary table. */

			if (read_write) {  //如果只读事务写临时表.也会分配事务 ID，也会加入rw_trx_ids，rw_trx_set

				trx_sys_mutex_enter();

				ut_ad(!srv_read_only_mode);

				trx->id = trx_sys_get_new_trx_id();  

				trx_sys->rw_trx_ids.push_back(trx->id);  

				trx_sys->rw_trx_set.insert(
					TrxTrack(trx->id, trx));

				trx_sys_mutex_exit();
			}

			trx->state = TRX_STATE_ACTIVE; //同样设定 事务状态为ACTIVE

		} else {
			ut_ad(!read_write);
			trx->state = TRX_STATE_ACTIVE;
		}
	}

	if (trx->mysql_thd != NULL) {
		trx->start_time = thd_start_time_in_secs(trx->mysql_thd);  //设置事务启动时间
	} else {
		trx->start_time = ut_time();
	}

	ut_a(trx->error_state == DB_SUCCESS);

	MONITOR_INC(MONITOR_TRX_ACTIVE);
}

```



## Update 语句执行

```
mysql> update test set age =1 where id =1;

row_search_mvcc() -> trx_start_if_not_started(trx, false)->trx_start_low()
trx_undo_report_row_operation() ->trans_commit_stmt(THD *thd)该函数判断了事务的锁信息和是否有子事务后 ->ha_commit_low() ->innobase_commit_low()->trx_commit_for_mysql(trx)->trx_commit()->trx_commit_low()->trx_commit_in_memory()
```

比 select 多了 记录Undo 日志的函数，

```C++
向一个undo log 写关于插入、更新或删除的信息，这个信息被用来回滚事务或MVCC。
@return DB_SUCCESS or error code */
dberr_t
trx_undo_report_row_operation(
/*==========================*/
	ulint		flags,		/*!< in: if BTR_NO_UNDO_LOG_FLAG bit is
					set, does nothing */
	ulint		op_type,	/*!< undo log 类型 ，插入或更改 */
	que_thr_t*	thr,		/*!< 查询线程 */
	dict_index_t*	index,		/*!< 聚集索引 */
	const dtuple_t*	clust_entry,	/*!< in:插入聚集索引的索引项 */
	const upd_t*	update,		/*!< in: 更新向量 */
	ulint		cmpl_info,	/*!< in: 用于辅助索引更新的信息 */
	const rec_t*	rec,		/*!< in: 更新或删除的主键信息 */
	const ulint*	offsets,	/*!< in: rec_get_offsets(rec) */
	roll_ptr_t*	roll_ptr)	/*!< out: 回滚指针指向这条Undo log  */
{
	trx_t*		trx;    //  声明一个事务 
	trx_undo_t*	undo;    // 声明一个  undo log 
	ulint		page_no; 
	buf_block_t*	undo_block;  
	trx_undo_ptr_t*	undo_ptr;  //表示回滚段的实例及状态变量。
	mtr_t		mtr;
	dberr_t		err		= DB_SUCCESS;
#ifdef UNIV_DEBUG
	int		loop_count	= 0;
#endif /* UNIV_DEBUG */

	ut_a(dict_index_is_clust(index));
	ut_ad(!rec || rec_offs_validate(rec, index, offsets));

	if (flags & BTR_NO_UNDO_LOG_FLAG) {  //这个应该是不做 undo log 

		*roll_ptr = 0;

		return(DB_SUCCESS);
	}

	ut_ad(thr);
	ut_ad(!srv_read_only_mode);
	ut_ad((op_type != TRX_UNDO_INSERT_OP)
	      || (clust_entry && !update && !rec));

	trx = thr_get_trx(thr);  // 获得该线程上的事务

	bool	is_temp_table = dict_table_is_temporary(index->table);  //判断是否是一个 临时表 ，临时表只在当前连接可见。

	/* Temporary tables do not go into INFORMATION_SCHEMA.TABLES,
	so do not bother adding it to the list of modified tables by
	the transaction - this list is only used for maintaining
	INFORMATION_SCHEMA.TABLES.UPDATE_TIME. */
	if (!is_temp_table) {     // 如果不是临时表 ，则
		trx->mod_tables.insert(index->table);   // 在事务的 mod_tables 中 插入 该表
	}

	/* If trx is read-only then only temp-tables can be written.
	If trx is read-write and involves temp-table only then we
	assign temporary rseg. */
	if (trx->read_only || is_temp_table) {  //如果事务是只读的，那么只能写入临时表，分配noredo 回滚段

		ut_ad(!srv_read_only_mode || is_temp_table);

		/* MySQL should block writes to non-temporary tables. */
		ut_a(is_temp_table);

		if (trx->rsegs.m_noredo.rseg == 0) {
			trx_assign_rseg(trx);   
		}
	}

	/* If object is temporary, disable REDO logging that is done to track
	changes done to UNDO logs. This is feasible given that temporary tables
	are not restored on restart. */
	mtr_start(&mtr);
	dict_disable_redo_if_temporary(index->table, &mtr);  // 检验是否是临时表，如果是临时表则不做redo log 
	mutex_enter(&trx->undo_mutex);

	/* If object is temp-table then select noredo rseg as changes
	to undo logs don't need REDO logging given that they are not
	restored on restart as corresponding object doesn't exist on restart.*/
	undo_ptr = is_temp_table ? &trx->rsegs.m_noredo : &trx->rsegs.m_redo;  //

	switch (op_type) {
	case TRX_UNDO_INSERT_OP:
		undo = undo_ptr->insert_undo;

		if (undo == NULL) {  // 如果是undo log为空，则分配 insert undo log 

			err = trx_undo_assign_undo(
				trx, undo_ptr, TRX_UNDO_INSERT);
			undo = undo_ptr->insert_undo;

			if (undo == NULL) {  //如果没有分配成功，则返回错误。
				/* Did not succeed */
				ut_ad(err != DB_SUCCESS);
				goto err_exit;
			}

			ut_ad(err == DB_SUCCESS);
		}
		break;
	default:
		ut_ad(op_type == TRX_UNDO_MODIFY_OP);

		undo = undo_ptr->update_undo;

		if (undo == NULL) {
			err = trx_undo_assign_undo(
				trx, undo_ptr, TRX_UNDO_UPDATE);
			undo = undo_ptr->update_undo;

			if (undo == NULL) {
				/* Did not succeed */
				ut_ad(err != DB_SUCCESS);
				goto err_exit;
			}
		}

		ut_ad(err == DB_SUCCESS);
	}

	page_no = undo->last_page_no;  // undo log 最后一页的 no 

	undo_block = buf_page_get_gen(
		page_id_t(undo->space, page_no), undo->page_size, RW_X_LATCH,
		buf_pool_is_obsolete(undo->withdraw_clock)
		? NULL : undo->guess_block, BUF_GET, __FILE__, __LINE__,
		&mtr);  // 访问 a database page ,返回一个指针指向 the block

	buf_block_dbg_add_level(undo_block, SYNC_TRX_UNDO_PAGE);

	do {  //写 undo log  
		page_t*		undo_page;
		ulint		offset;

		undo_page = buf_block_get_frame(undo_block); //undo page 的地址
		ut_ad(page_no == undo_block->page.id.page_no());

		switch (op_type) {
		case TRX_UNDO_INSERT_OP:
			offset = trx_undo_page_report_insert(
				undo_page, trx, index, clust_entry, &mtr); //插入主键，返回偏移
			break;
		default:
			ut_ad(op_type == TRX_UNDO_MODIFY_OP);
			offset = trx_undo_page_report_modify(
				undo_page, trx, index, rec, offsets, update,
				cmpl_info, clust_entry, &mtr);  //插入主键 ，表行记录，
		}

		if (UNIV_UNLIKELY(offset == 0)) { //如果 失败了，则擦除撤销日志页面的结束部分并将其写入日志记录。
			/* The record did not fit on the page. We erase the
			end segment of the undo log page and write a log
			record of it: this is to ensure that in the debug
			version the replicate page constructed using the log
			records stays identical to the original page */

			if (!trx_undo_erase_page_end(undo_page, &mtr)) {
				/* The record did not fit on an empty
				undo page. Discard the freshly allocated
				page and return an error. */

				/* When we remove a page from an undo
				log, this is analogous to a
				pessimistic insert in a B-tree, and we
				must reserve the counterpart of the
				tree latch, which is the rseg
				mutex. We must commit the mini-transaction
				first, because it may be holding lower-level
				latches, such as SYNC_FSP and SYNC_FSP_PAGE. */

				mtr_commit(&mtr);
				mtr_start(&mtr);
				dict_disable_redo_if_temporary(
					index->table, &mtr);

				mutex_enter(&undo_ptr->rseg->mutex);
				trx_undo_free_last_page(trx, undo, &mtr);
				mutex_exit(&undo_ptr->rseg->mutex);

				err = DB_UNDO_RECORD_TOO_BIG;
				goto err_exit;
			}

			mtr_commit(&mtr);
		} else {
			/* Success */
			undo->withdraw_clock = buf_withdraw_clock;
			mtr_commit(&mtr);

			undo->empty = FALSE;
			undo->top_page_no = page_no;
			undo->top_offset  = offset;
			undo->top_undo_no = trx->undo_no;
			undo->guess_block = undo_block;

			trx->undo_no++;
			trx->undo_rseg_space = undo_ptr->rseg->space;

			mutex_exit(&trx->undo_mutex);

			*roll_ptr = trx_undo_build_roll_ptr(
				op_type == TRX_UNDO_INSERT_OP,
				undo_ptr->rseg->id, page_no, offset);// 返回roll_ptr 
			return(DB_SUCCESS);
		}

		ut_ad(page_no == undo->last_page_no);

		/* 扩展 undo log  */

		ut_ad(++loop_count < 2);
		mtr_start(&mtr);
		dict_disable_redo_if_temporary(index->table, &mtr);

		/* When we add a page to an undo log, this is analogous to
		a pessimistic insert in a B-tree, and we must reserve the
		counterpart of the tree latch, which is the rseg mutex. */

		mutex_enter(&undo_ptr->rseg->mutex);
		undo_block = trx_undo_add_page(trx, undo, undo_ptr, &mtr);// 添加 undo page 
		mutex_exit(&undo_ptr->rseg->mutex);

		page_no = undo->last_page_no;

		DBUG_EXECUTE_IF("ib_err_ins_undo_page_add_failure",
				undo_block = NULL;);
	} while (undo_block != NULL);

	ib_errf(trx->mysql_thd, IB_LOG_LEVEL_ERROR,
		ER_INNODB_UNDO_LOG_FULL,
		"No more space left over in %s tablespace for allocating UNDO"
		" log pages. Please add new data file to the tablespace or"
		" check if filesystem is full or enable auto-extension for"
		" the tablespace",
		((undo->space == srv_sys_space.space_id())
		? "system" :
		  ((fsp_is_system_temporary(undo->space))
		   ? "temporary" : "undo")));

	/* Did not succeed: out of space */
	err = DB_OUT_OF_FILE_SPACE;

err_exit:
	mutex_exit(&trx->undo_mutex);
	mtr_commit(&mtr);
	return(err);
}
```

trx_commit_in_memory()  函数代码：

```c++
/****************************************************************/
/**Commits a transaction in memory. */
static
void
trx_commit_in_memory(
/*=================*/
trx_t* trx, /*!< in/out: transaction */
const mtr_t* mtr, /*!< in: mini-transaction of
trx_write_serialisation_history(), or NULL if
the transaction did not modify anything */  // 写事务具有mtr 如果没有更改任何东西则为NULL 
bool serialised)/*!< in: true if serialisation log was written */
{
trx->must_flush_log_later = false;
if (trx_is_autocommit_non_locking(trx)) { //如果这个事务时非锁定的自动提交的select 事务
ut_ad(trx->id == 0);
ut_ad(trx->read_only);
ut_a(!trx->is_recovered);
ut_ad(trx->rsegs.m_redo.rseg == NULL);
ut_ad(!trx->in_rw_trx_list);
/* Note: We are asserting without holding the lock mutex. But that is OK because this transaction is not waiting and cannot be rolled back and no new locks can (or should not) be added becuase it is flagged as a non-locking read-only transaction. */
ut_a(UT_LIST_GET_LEN(trx->lock.trx_locks) == 0);
/* This state change is not protected by any mutex, therefore there is an inherent race here around state transition during printouts. We ignore this race for the sake of efficiency. However, the trx_sys_t::mutex will protect the trx_t instance and it cannot be removed from the mysql_trx_list and freed without first acquiring the trx_sys_t::mutex. */
ut_ad(trx_state_eq(trx, TRX_STATE_ACTIVE));
if (trx->read_view != NULL) {  //如果 readview 不为空。则关闭 read view 
trx_sys->mvcc->view_close(trx->read_view, false);
}
MONITOR_INC(MONITOR_TRX_NL_RO_COMMIT);  //监视计数器，
/* AC-NL-RO transactions can't be rolled back asynchronously. */
ut_ad(!trx->abort);
ut_ad(!(trx->in_innodb
& (TRX_FORCE_ROLLBACK | TRX_FORCE_ROLLBACK_ASYNC)));
trx->state = TRX_STATE_NOT_STARTED;  //设置 事务状态为未启动
} else {
if (trx->id > 0) {  //如果为 读写事务
/* For consistent snapshot, we need to remove current transaction from running transaction id list for mvcc before doing commit and releasing locks. */
trx_erase_lists(trx, serialised);   //从running transaction id list 移除该事务
}
lock_trx_release_locks(trx); //释放锁
/* Remove the transaction from the list of active transactions now that it no longer holds any user locks. */
ut_ad(trx_state_eq(trx, TRX_STATE_COMMITTED_IN_MEMORY));
DEBUG_SYNC_C("after_trx_committed_in_memory");
if (trx->read_only || trx->rsegs.m_redo.rseg == NULL) { //如果是只读事务或者该事物 没有写redo 
MONITOR_INC(MONITOR_TRX_RO_COMMIT);  
if (trx->read_view != NULL) { //如果该readview 不为空，则关闭readview 
trx_sys->mvcc->view_close(
trx->read_view, false);
}
} else {
ut_ad(trx->id > 0);
MONITOR_INC(MONITOR_TRX_RW_COMMIT);
}
}
if (trx->rsegs.m_redo.rseg != NULL) { //如果写了redo  ，则在 回滚段中把trx_ref_count-1
trx_rseg_t* rseg = trx->rsegs.m_redo.rseg;  
mutex_enter(&rseg->mutex);
ut_ad(rseg->trx_ref_count > 0);
--rseg->trx_ref_count;
mutex_exit(&rseg->mutex);
}
if (mtr != NULL) {
if (trx->rsegs.m_redo.insert_undo != NULL) { //如果事务回滚段 中inser_undo 不为空，则清除insert_undo  
trx_undo_insert_cleanup(&trx->rsegs.m_redo, false);
}
if (trx->rsegs.m_noredo.insert_undo != NULL) {
trx_undo_insert_cleanup(&trx->rsegs.m_noredo, true);
}
/* NOTE that we could possibly make a group commit more efficient here: call os_thread_yield here to allow also other trxs to come to commit! */
/*-------------------------------------*/
/* 我们现在可以将日志缓冲区写入日志文件，也可以在写入日志文件后进行fsync将日志文件写入磁盘.group commit 是每次刷到磁盘时刷新一组事务。*/
lsn_t lsn = mtr->commit_lsn();
if (lsn == 0) {
/* Nothing to be done. */
} else if (trx->flush_log_later) {
/* Do nothing yet */
trx->must_flush_log_later = true;
} else if (srv_flush_log_at_trx_commit == 0
|| thd_requested_durability(trx->mysql_thd)
== HA_IGNORE_DURABILITY) {
/* Do nothing */
} else {    //此时需要立刻将 redo 持久化
}
trx->commit_lsn = lsn; //把mtr提交的lsn赋值给事务trx
/* Tell server some activity has happened, since the trx does changes something. Background utility threads like master thread, purge thread or page_cleaner thread might have some work to do. */
srv_active_wake_master_thread(); //唤醒主线程
}
/* 释放所有的保存点 ，b*/
trx_named_savept_t* savep = UT_LIST_GET_FIRST(trx->trx_savepoints);
trx_roll_savepoints_free(trx, savep);
if (trx->fts_trx != NULL) {
trx_finalize_for_fts(trx, trx->undo_no != 0);
}
trx_mutex_enter(trx);
trx->dict_operation = TRX_DICT_OP_NONE;
/* Because we can rollback transactions asynchronously, we change the state at the last step. trx_t::abort cannot change once commit or rollback has started because we will have released the locks by the time we get here. */
if (trx->abort) {
trx->abort = false;
trx->state = TRX_STATE_FORCED_ROLLBACK;
} else {
trx->state = TRX_STATE_NOT_STARTED;
}
/* trx->in_mysql_trx_list would hold between trx_allocate_for_mysql() and trx_free_for_mysql(). It does not hold for recovered transactions or system transactions. */
assert_trx_is_free(trx);
trx_init(trx);  //初始化 事务
trx_mutex_exit(trx);
ut_a(trx->error_state == DB_SUCCESS);
}
```

该函数大概做了：

- 判断事务是否为`非锁定的自动提交的select事务`，如果是则关闭其readview ，并设置其状态为未启动；否则如果其为读写事务，则将这个事务从`trx_sys->serialisation_list`、`trx_sys->rw_trx_ids`、`trx_sys->rw_trx_list`、`trx->read_view`和`trx_sys->rw_trx_set`中删除，并且释放其所拥有的锁，或者其不是读写事务，只释放readiew。
- 如果其`trx->rsegs.m_redo.rseg != NULL`，则在将其`--rseg->trx_ref_count;`
- 如果`mtr != NULL`，则删除其`insert_undo`，如果`trx->flush_log_later==true`,则将`trx->must_flush_log_later = true;`,并在`trx_commit_complete_for_mysql()`中将日志持久化。如果必须要立刻持久化则唤醒主线程来做，将redo 日志刷到`trx->commit_lsn`的位置。
- 设置事务状态，初始化事务。



回滚段结构体

```C++
/** 被分配给事务的一些回滚段 */
struct trx_rsegs_t {
	/** undo log ptr holding reference to a rollback segment that resides in
	system/undo tablespace used for undo logging of tables that needs
	to be recovered on crash. */
	trx_undo_ptr_t	m_redo; // 指向需要写redo  的回滚段

	/** undo log ptr holding reference to a rollback segment that resides in
	temp tablespace used for undo logging of tables that doesn't need
	to be recovered on crash. */
	trx_undo_ptr_t	m_noredo; //不需要写redo 的 回滚段
};


/*表示回滚段的实例及其状态变量。*/
struct trx_undo_ptr_t {
	trx_rseg_t*	rseg;		/*!< rollback segment assigned to the
					transaction, or NULL if not assigned
					yet */
	trx_undo_t*	insert_undo;	/*!< 指向 insert undo log  */
	trx_undo_t*	update_undo;	/*!< 指向 unpdate undo log  */
};


/** 回滚段 对象 */
struct trx_rseg_t {
	/*--------------------------------------------------------*/
	/** rollback segment id == the index of its slot in the trx
	system file copy */
	ulint				id;  //事务系统文件中 的 slot index 

	/** mutex protecting the fields in this struct except id,space,page_no
	which are constant */
	RsegMutex			mutex;

	/** space where the rollback segment header is placed */
	ulint				space; // 回滚段 头部所在的 space 

	/** page number of the rollback segment header */
	ulint				page_no;  //回滚段 头部所在的 page 

	/** page size of the relevant tablespace */
	page_size_t			page_size; // 表空间的页的大小

	/** maximum allowed size in pages */
	ulint				max_size;

	/** current size in pages */
	ulint				curr_size;

	/*--------------------------------------------------------*/
	/* Fields for update undo logs */
	/** List of update undo logs */
	UT_LIST_BASE_NODE_T(trx_undo_t)	update_undo_list; //  该 回滚段中 update_undo_list 

	/** List of update undo log segments cached for fast reuse */
	UT_LIST_BASE_NODE_T(trx_undo_t)	update_undo_cached; //  该 回滚段中可以重用的 update_undo_cached

	/*--------------------------------------------------------*/
	/* Fields for insert undo logs */
	/** List of insert undo logs */
	UT_LIST_BASE_NODE_T(trx_undo_t) insert_undo_list;//  该 回滚段中 insert_undo_list

	/** List of insert undo log segments cached for fast reuse */
	UT_LIST_BASE_NODE_T(trx_undo_t) insert_undo_cached;//可以重用的insert_undo_cached

	/*--------------------------------------------------------*/

	/** Page number of the last not yet purged log header in the history
	list; FIL_NULL if all list purged */
	ulint				last_page_no;  //  History  中未被 Purge的 最后一个页号码

	/** Byte offset of the last not yet purged log header */
	ulint				last_offset; //字节偏移 

	/** Transaction number of the last not yet purged log */
	trx_id_t			last_trx_no;  // 最后没有被 purge 的 事务id 

	/** TRUE if the last not yet purged log needs purging */
	ibool				last_del_marks; // 如果最后一个 没有被 purge 的log  需要 purge 时 是正确的

	/** Reference counter to track rseg allocated transactions. */
	ulint				trx_ref_count; //回滚段中分配的事务 数

	/** If true, then skip allocating this rseg as it reside in
	UNDO-tablespace marked for truncate. */
	bool				skip_allocation; //如果为true ，然后 跳过分配该回滚段
};


// undo  段 结构体
struct trx_undo_t {
	/*-----------------------------*/
	ulint		id;		/*回滚段中的slot number */
	ulint		type;		/*!< TRX_UNDO_INSERT or
					TRX_UNDO_UPDATE */
	ulint		state;		/*!< undo log
					segment 的状态*/
	ibool		del_marks;	/* 该参数仅在 update undo log ,当事务含有delete marked records 时为true,如果事务已经更新了外部存储的字段，这也是正确的*/
	trx_id_t	trx_id;		/*!< 分配给 这个undo log 的事务 id  */
	XID		xid;		/*!< X/Open XA transaction
					identification */
	ibool		dict_operation;	/* 如果时字典操作事务则为true */
	table_id_t	table_id;	/*!< 如果时字典id ，则为表id  */
	trx_rseg_t*	rseg;		/* 该undo log 属于的 回滚段 */
	/*-----------------------------*/
	ulint		space;		/*!< space id where the undo log
					placed */
	page_size_t	page_size;
	ulint		hdr_page_no;	/*!< page number of the header page in
					the undo log */
	ulint		hdr_offset;	/*!< header offset of the undo log on
				       	the page */
	ulint		last_page_no;	/*!< page number of the last page in the
					undo log; this may differ from
					top_page_no during a rollback */
	ulint		size;		/*!< current size in pages */
	/*-----------------------------*/
	ulint		empty;		/*!< 如果当前没有 undo record log 则为true */
	ulint		top_page_no;	/*最新的undo log record 所在的页，回滚的时候从最新额record 开始回滚 */
	ulint		top_offset;	/*!< offset of the latest undo record,
					i.e., the topmost element in the undo
					log if we think of it as a stack */
	undo_no_t	top_undo_no;	/*!< 最新的undo log record 的undo_no */
	buf_block_t*	guess_block;	/*!<最新的记录页可能在的块 */
	ulint		withdraw_clock;	/*!< the withdraw clock value of the
					buffer pool when guess_block was stored */
	/*-----------------------------*/
	UT_LIST_NODE_T(trx_undo_t) undo_list;
					/*!< 在这个回滚段的 undo log 被链接在这个列表中 */
};
```



## 包含 select、update和insert 的事务执行

### use  test

![](C:\Users\Administrator\Desktop\Mysql 技术内幕\图片\360截图16720328588652.jpg)



先运行了该函数**dict_stats_fetch_from_ps(dict_table_t*	table)** ，该函数大概是从数据字典中读取表的统计信息。该函数会调用一下几个事务函数：

-  `trx_allocate_for_background();`  由master thread 生成的为后台操作的事务。
- `trx_start_internal(trx);`：开启内部事务
- `trx_commit_for_mysql(trx);`：事务提交
- `trx_free_for_background`：释放事务对象，回归事务缓冲池。

接下来会把表的统计信息传给mysql 解释器（`ha_innobase::info_low`，该函数会调用`ha_innobase::update_thd`（该函数更新用户线程，分配一个新的InnoDB 事务句柄，并更新事务属性）。同样会涉及到：

![](C:\Users\Administrator\Desktop\Mysql 技术内幕\图片\360截图1786053187101122.jpg)

- `check_trx_exists`： 检测该用户线程是否存在事务，不存在则由innoDB从事务缓冲池中分配一个事务。



### begin

开始一条事务，但是该语句没有进入innoDB 层， 其作用是1. 提交上次未显示提交的事务，释放已经存在的锁2.设置线程的状态变量

其涉及的函数是`trans_begin(thd, lex‑>start_transaction_opt) `

```C++
/*开启一个事务。另外，会隐式提交上个未完成的事务（或事务性的命令如 flush tables），并释放thd所拥有的表锁。*/
//@note Beginning a transaction implicitly commits any current
//transaction and releases existing locks.
//@param thd Current thread
//@param flags Transaction flags
//@retval FALSE Success
//@retval TRUE Failure
bool trans_begin(THD *thd, uint flags)
{
int res= FALSE;
Transaction_state_tracker *tst= NULL;
/* 本段代码设置thd的session_tracker变量，此变量功能后面阅读 { */
if (thd->variables.session_track_transaction_info > TX_TRACK_NONE)
tst= (Transaction_state_tracker *)
thd->session_tracker.get_tracker(TRANSACTION_INFO_TRACKER);
/*} */
//释放此thd拥有的表锁
thd->locked_tables_list.unlock_locked_tables(thd);
/* 检测thd是否处于`多语句事务状态`，处于该状态说明上一个事务，或事务性的命令（拥有表锁OPTION_TABLE_LOCK）没有提交，则调用ha_commit_trans()先提交该事务或命令。{ */
if (thd->in_multi_stmt_transaction_mode() ||
(thd->variables.option_bits & OPTION_TABLE_LOCK))
{
thd->variables.option_bits&= ~OPTION_TABLE_LOCK;
thd->server_status&=
~(SERVER_STATUS_IN_TRANS | SERVER_STATUS_IN_TRANS_READONLY);
DBUG_PRINT("info", ("clearing SERVER_STATUS_IN_TRANS"));
res= MY_TEST(ha_commit_trans(thd, TRUE));
}
/* } */
//清除OPTION_BEGIN标识/reset unsafe_rollback_flags,
//unsafe_rollback_flag表明该事务可能修改了不支持事务的表
thd->variables.option_bits&= ~OPTION_BEGIN;
thd->get_transaction()->reset_unsafe_rollback_flags(Transaction_ctx::SESSION);
//如果res != FALSE，则说明上一个事务已经正常提交，则直接返回。
//这里直接返回是什么意思？也就是这个begin语句只是提交上个事务？后面再看
if (res)
DBUG_RETURN(TRUE);
/*释放已提交事务的transactional metadata locks。*/
thd->mdl_context.release_transactional_locks();
/* 根据传入的flags判断开启的是RO还是RW事务 *{ */
//如果以显式的READ_ONLY开启，则设置线程thd的RO属性
if (flags & MYSQL_START_TRANS_OPT_READ_ONLY)
{
thd->tx_read_only= true;
if (tst)
tst->set_read_flags(thd, TX_READ_ONLY);
}
//如果以显式的READ_WRITE开启，则设置线程thd的RW属性
else if (flags & MYSQL_START_TRANS_OPT_READ_WRITE)
{
/*Explicitly starting a RW transaction when the server is in read-only mode, is not allowed unless the user has SUPER priv.Implicitly starting a RW transaction is allowed for backward compatibility. */
if (check_readonly(thd, true))
DBUG_RETURN(true);
thd->tx_read_only= false;
/*This flags that tx_read_only was set explicitly, rather than just from the session's default.*/
if (tst)
tst->set_read_flags(thd, TX_READ_WRITE);
}
//设置thd的标志位，标识事务开始
thd->variables.option_bits|= OPTION_BEGIN;
thd->server_status|= SERVER_STATUS_IN_TRANS;
if (thd->tx_read_only)
thd->server_status|= SERVER_STATUS_IN_TRANS_READONLY;
DBUG_PRINT("info", ("setting SERVER_STATUS_IN_TRANS"));
if (tst)
tst->add_trx_state(thd, TX_EXPLICIT);
/* ha_start_consistent_snapshot() relies on OPTION_BEGIN flag set. */
/* 如果以START TRANSACTION WITH consistent snapshot 开启事务*/
if (flags & MYSQL_START_TRANS_OPT_WITH_CONS_SNAPSHOT)
{
if (tst)
tst->add_trx_state(thd, TX_WITH_SNAPSHOT);
//下面这句代码分配ReadView？
res= ha_start_consistent_snapshot(thd);
}
DBUG_RETURN(MY_TEST(res));
}
```

### select * from test;

从 `row_search_mvcc`中进入 `trx_start_low `函数开启事务

### update test set age = 7 where id =1;

执行` trx_set_rw_mode`将事务设置为读写事务。

### insert into test values(7,"7","7");

### commit;

`innobase_commit`